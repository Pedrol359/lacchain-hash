{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_24-a425868d7c79aee58a7f36e0d98164b683129134",
  "solcVersion": "0.8.24",
  "solcLongVersion": "0.8.24+commit.e11b9ed9",
  "userSourceNameMap": {
    "contracts/BaseRelayRecipient.sol": "project/contracts/BaseRelayRecipient.sol",
    "contracts/StorageHash.sol": "project/contracts/StorageHash.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "shanghai",
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/BaseRelayRecipient.sol": {
        "content": "// SPDX-License-Identifier:MIT\npragma solidity >=0.8.0 <0.9.0;\n\n/**\n * A base contract to be inherited by any contract that want to receive relayed transactions\n * A subclass must use \"_msgSender()\" instead of \"msg.sender\"\n */\nabstract contract BaseRelayRecipient{\n\n   /*\n    * Forwarder singleton we accept calls from\n    */\n   //address internal trustedForwarder = 0xa4B5eE2906090ce2cDbf5dfff944db26f397037D; //local\n\n   address internal trustedForwarder = 0xa4B5eE2906090ce2cDbf5dfff944db26f397037D;  //open-protestnet\n\n   //address internal trustedForwarder = 0xEAA5420AF59305c5ecacCB38fcDe70198001d147; //mainnet\n\n   /**\n    * return the sender of this call.\n    * if the call came through our Relay Hub, return the original sender.\n    * should be used in the contract anywhere instead of msg.sender\n    */\n   function _msgSender() internal virtual returns (address sender) {\n       bytes memory bytesRelayHub;\n       (,bytesRelayHub) = trustedForwarder.call(abi.encodeWithSignature(\"getRelayHub()\"));\n       if (msg.sender == abi.decode(bytesRelayHub, (address))){ //sender is RelayHub then return origin sender\n           bytes memory bytesSender;\n           (,bytesSender) = trustedForwarder.call(abi.encodeWithSignature(\"getMsgSender()\"));\n\n           return abi.decode(bytesSender, (address));\n       } else { //sender is not RelayHub, so it is another smart contract\n           return msg.sender;\n       }\n   }\n}"
      },
      "project/contracts/StorageHash.sol": {
        "content": "// SPDX-License-Identifier:UNLICENSED\npragma solidity ^0.8.24;\n\nimport \"./BaseRelayRecipient.sol\";\n\ncontract StorageHash is BaseRelayRecipient {\n\n    address public owner;\n    mapping(bytes32 => bool) public exists;\n    mapping(bytes32 => uint256) public storedAt;\n    mapping(bytes32 => address) public storedBy;\n\n    event HashStored(address indexed by, bytes32 indexed hashValue, uint256 timestamp);\n\n    constructor() {\n        owner = _msgSender();\n    }\n\n    /// Guarda un hash bytes32 s√≥lo si no existe (inmutable por hash)\n    function storeHash(bytes32 _h) public {\n        require(_h != bytes32(0), \"Invalid hash\");\n        require(!exists[_h], \"Hash already stored\");\n\n        exists[_h] = true;\n        storedAt[_h] = block.timestamp;\n        storedBy[_h] = _msgSender();\n\n        emit HashStored(_msgSender(), _h, block.timestamp);\n    }\n\n    function isStored(bytes32 _h) public view returns (bool) {\n        return exists[_h];\n    }\n}"
      }
    }
  }
}